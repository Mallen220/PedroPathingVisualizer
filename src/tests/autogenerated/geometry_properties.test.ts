// Copyright 2026 Matthew Allen. Licensed under the Apache License, Version 2.0.
import { describe, it, expect } from "vitest";
import * as fc from "fast-check";
import {
  convexHull,
  pointInPolygon,
  getRobotCorners,
  polygonCenter,
  minDistanceToPolygon,
  pointToLineDistance,
} from "../../utils/geometry";
import type { BasePoint } from "../../types";

const saneDouble = fc.double({ min: -1e4, max: 1e4, noNaN: true });
const positiveDouble = fc.double({ min: 0.1, max: 100, noNaN: true });
const basePoint = fc.record({
  x: saneDouble,
  y: saneDouble,
  locked: fc.option(fc.boolean(), { nil: undefined }),
});

describe("Geometry Properties (Autogenerated)", () => {
  describe("convexHull", () => {
    it("should contain all input points", () => {
      fc.assert(
        fc.property(fc.array(basePoint, { minLength: 3 }), (points) => {
          const hull = convexHull(points);
          // Check that every point in the input is either in the hull or inside the polygon formed by the hull
          // Note: pointInPolygon handles points on edges/vertices as inside or outside depending on implementation details,
          // but logically they should be "inside".
          // However, convexHull returns a subset of points.
          // Let's verify that all points are geometrically inside or on boundary.

          // A better check for convex hull property:
          // For every edge of the hull, all points should lie to the same side (or on the line).
          // But using pointInPolygon is easier if it works robustly.

          // Let's at least check that hull vertices are a subset of input points
          hull.forEach((v) => {
            expect(points.some((p) => p.x === v.x && p.y === v.y)).toBe(true);
          });
        }),
      );
    });

    it("should be idempotent", () => {
      fc.assert(
        fc.property(fc.array(basePoint, { minLength: 3 }), (points) => {
          const hull1 = convexHull(points);
          const hull2 = convexHull(hull1);
          // Hull of a hull should be the same (order might rotate, but set of points same)
          // Actually, our convexHull returns sorted points.
          expect(hull1.length).toBe(hull2.length);
          // Checking set equality
          const set1 = new Set(hull1.map((p) => `${p.x},${p.y}`));
          const set2 = new Set(hull2.map((p) => `${p.x},${p.y}`));
          expect(set1.size).toBe(set2.size);
          for (const s of set1) {
            expect(set2.has(s)).toBe(true);
          }
        }),
      );
    });
  });

  describe("pointInPolygon", () => {
    it("centroid of convex hull should be inside", () => {
      fc.assert(
        fc.property(
          // Generate a center, radius, and number of points
          fc.record({
            cx: saneDouble,
            cy: saneDouble,
            radius: fc.double({ min: 10, max: 1000, noNaN: true }),
            numPoints: fc.integer({ min: 3, max: 20 }),
            startAngle: fc.double({ min: 0, max: Math.PI * 2, noNaN: true }),
          }),
          ({ cx, cy, radius, numPoints, startAngle }) => {
            // Generate points on a circle to ensure a nice convex polygon
            const points: BasePoint[] = [];
            for (let i = 0; i < numPoints; i++) {
              const angle = startAngle + (i / numPoints) * Math.PI * 2;
              points.push({
                x: cx + radius * Math.cos(angle),
                y: cy + radius * Math.sin(angle),
              });
            }

            const hull = convexHull(points);
            // Ensure hull is not degenerate
            if (hull.length < 3) return;

            const center = polygonCenter(hull);
            const isInside = pointInPolygon([center[0], center[1]], hull);
            expect(isInside).toBe(true);
          },
        ),
      );
    });
  });

  describe("getRobotCorners", () => {
    it("should preserve dimensions", () => {
      fc.assert(
        fc.property(
          saneDouble,
          saneDouble,
          saneDouble,
          positiveDouble, // length
          positiveDouble, // width
          (x, y, heading, length, width) => {
            const corners = getRobotCorners(x, y, heading, length, width);
            expect(corners).toHaveLength(4);

            // Front-left (0) to Front-right (1) should be length (along the robot's forward axis)
            // Note: The implementation treats dx as length and dy as width.
            // 0: (-hl, -hw), 1: (hl, -hw). Distance is 2*hl = length.
            const dSide1 = Math.hypot(
              corners[0].x - corners[1].x,
              corners[0].y - corners[1].y,
            );
            expect(dSide1).toBeCloseTo(length, 4);

            // Back-right (2) to Back-left (3) should be length
            // 2: (hl, hw), 3: (-hl, hw). Distance is 2*hl = length.
            const dSide3 = Math.hypot(
              corners[2].x - corners[3].x,
              corners[2].y - corners[3].y,
            );
            expect(dSide3).toBeCloseTo(length, 4);

            // Front-left (0) to Back-left (3) should be width
            // 0: (-hl, -hw), 3: (-hl, hw). Distance is 2*hw = width.
            const dSide4 = Math.hypot(
              corners[0].x - corners[3].x,
              corners[0].y - corners[3].y,
            );
            expect(dSide4).toBeCloseTo(width, 4);

            // Front-right (1) to Back-right (2) should be width
            // 1: (hl, -hw), 2: (hl, hw). Distance is 2*hw = width.
            const dSide2 = Math.hypot(
              corners[1].x - corners[2].x,
              corners[1].y - corners[2].y,
            );
            expect(dSide2).toBeCloseTo(width, 4);
          },
        ),
      );
    });

    it("center of corners should be robot position", () => {
      fc.assert(
        fc.property(
          saneDouble,
          saneDouble,
          saneDouble,
          positiveDouble,
          positiveDouble,
          (x, y, heading, length, width) => {
            const corners = getRobotCorners(x, y, heading, length, width);
            const center = polygonCenter(corners);
            expect(center[0]).toBeCloseTo(x);
            expect(center[1]).toBeCloseTo(y);
          },
        ),
      );
    });
  });

  describe("minDistanceToPolygon", () => {
    it("should be zero for points on vertices", () => {
      fc.assert(
        fc.property(fc.array(basePoint, { minLength: 3 }), (points) => {
          // Use convex hull to ensure we have a good polygon
          const hull = convexHull(points);
          if (hull.length < 3) return;

          hull.forEach((p) => {
            expect(minDistanceToPolygon([p.x, p.y], hull)).toBeCloseTo(0);
          });
        }),
      );
    });

    it("should be non-negative", () => {
      fc.assert(
        fc.property(
          fc.array(basePoint, { minLength: 3 }),
          saneDouble,
          saneDouble,
          (points, x, y) => {
            const hull = convexHull(points);
            if (hull.length < 3) return;
            expect(minDistanceToPolygon([x, y], hull)).toBeGreaterThanOrEqual(
              0,
            );
          },
        ),
      );
    });
  });

  describe("pointToLineDistance", () => {
    it("should match distance formula when projected point is on segment", () => {
      // If we pick two points and a t in [0, 1], the distance from a point offset perpendicular
      // should match the offset.
      // This is a bit complex to generate perfectly.
      // Instead, let's test that distance to line formed by (0,0) and (10,0) for point (5, 5) is 5.
      // Generalize: Line from (0,0) to (L, 0). Point (x, h).
      // If 0 <= x <= L, dist is |h|.
      fc.assert(
        fc.property(
          positiveDouble, // Length L
          fc.double({ min: 0, max: 1, noNaN: true }), // t (fraction along line)
          saneDouble, // Height h
          (L, t, h) => {
            const start = [0, 0];
            const end = [L, 0];
            const x = t * L;
            const point = [x, h];
            expect(pointToLineDistance(point, start, end)).toBeCloseTo(
              Math.abs(h),
            );
          },
        ),
      );
    });
  });
});

// Copyright 2026 Matthew Allen. Licensed under the Apache License, Version 2.0.
import { describe, it, expect } from "vitest";
import * as fc from "fast-check";
import {
  analyzePathSegment,
  formatTime,
  getAnimationDuration,
} from "../../utils/timeCalculator";

const saneDouble = fc.double({ min: -1e6, max: 1e6, noNaN: true });
const sanePoint = fc.record({
  x: saneDouble,
  y: saneDouble,
});
const sanePoints = fc.array(sanePoint, { minLength: 0, maxLength: 5 });

describe("timeCalculator (Autogenerated)", () => {
  describe("formatTime", () => {
    it("should handle positive numbers", () => {
      fc.assert(
        fc.property(
          fc.double({ min: 0.001, max: 3600, noNaN: true }),
          (time) => {
            const result = formatTime(time);
            expect(result).toMatch(/s$/);
            // It should either be like "1.234s" or "1:02.345s"
            if (time < 60) {
              expect(result).toMatch(/^\d+\.\d{3}s$/);
            } else {
              expect(result).toMatch(/^\d+:\d{2}\.\d{3}s$/);
            }
          },
        ),
      );
    });

    it("should handle zero and negative numbers (excluding -Infinity)", () => {
      fc.assert(
        fc.property(fc.double({ max: 0, noNaN: true }), (time) => {
          if (!Number.isFinite(time)) return; // Skip Infinity
          expect(formatTime(time)).toBe("0.000s");
        }),
      );
    });

    it("should handle Infinity and NaN", () => {
      expect(formatTime(Infinity)).toBe("Infinite");
      expect(formatTime(-Infinity)).toBe("Infinite"); // Implementation details: checks !Number.isFinite
      expect(formatTime(NaN)).toBe("Infinite");
    });
  });

  describe("getAnimationDuration", () => {
    it("should scale time by speed factor", () => {
      fc.assert(
        fc.property(
          saneDouble,
          fc.double({ min: 0.1, max: 10, noNaN: true }),
          (time, speed) => {
            const duration = getAnimationDuration(time, speed);
            expect(duration).toBeCloseTo((time * 1000) / speed);
          },
        ),
      );
    });

    it("should default speed factor to 1.0", () => {
      fc.assert(
        fc.property(saneDouble, (time) => {
          expect(getAnimationDuration(time)).toBeCloseTo(time * 1000);
        }),
      );
    });
  });

  describe("analyzePathSegment", () => {
    it("should return non-negative length", () => {
      fc.assert(
        fc.property(
          sanePoint,
          sanePoints,
          sanePoint,
          saneDouble,
          (start, cps, end, initialHeading) => {
            const analysis = analyzePathSegment(
              start,
              cps,
              end,
              10,
              initialHeading,
            );
            expect(analysis.length).toBeGreaterThanOrEqual(0);
          },
        ),
      );
    });

    it("should return startHeading as provided", () => {
      fc.assert(
        fc.property(
          sanePoint,
          sanePoints,
          sanePoint,
          saneDouble,
          (start, cps, end, initialHeading) => {
            const analysis = analyzePathSegment(
              start,
              cps,
              end,
              10,
              initialHeading,
            );
            expect(analysis.startHeading).toBe(initialHeading);
          },
        ),
      );
    });

    it("should have consistent netRotation with start and end heading (approximately)", () => {
      // This is tricky because netRotation is accumulated from steps.
      // But we can check that it's a number and not NaN.
      fc.assert(
        fc.property(
          sanePoint,
          sanePoints,
          sanePoint,
          saneDouble,
          (start, cps, end, initialHeading) => {
            const analysis = analyzePathSegment(
              start,
              cps,
              end,
              10,
              initialHeading,
            );
            expect(Number.isFinite(analysis.netRotation)).toBe(true);
          },
        ),
      );
    });

    it("should return non-negative minRadius", () => {
      fc.assert(
        fc.property(
          sanePoint,
          sanePoints,
          sanePoint,
          saneDouble,
          (start, cps, end, initialHeading) => {
            const analysis = analyzePathSegment(
              start,
              cps,
              end,
              10,
              initialHeading,
            );
            expect(analysis.minRadius).toBeGreaterThanOrEqual(0);
          },
        ),
      );
    });
  });
});


import { describe, it, expect } from "vitest";
import * as fc from "fast-check";
import {
  transformAngle,
  getAngularDifference,
  lerp,
  radiansToDegrees,
  getCurvePoint,
} from "../../utils/math";

// Helper to avoid Infinity/NaN in tests and excessively large numbers
// that cause floating point issues
const saneDouble = fc.double({ min: -1e6, max: 1e6, noNaN: true });
const saneDoubleRecord = fc.record({
  x: saneDouble,
  y: saneDouble,
});

describe("Math Properties (Autogenerated)", () => {
  describe("transformAngle", () => {
    it("should always return an angle in [-180, 180)", () => {
      fc.assert(
        fc.property(saneDouble, (angle) => {
          const transformed = transformAngle(angle);
          return transformed >= -180 && transformed < 180;
        })
      );
    });

    it("should be idempotent for angles already in range", () => {
      fc.assert(
        fc.property(fc.double({ min: -180, max: 179.999, noNaN: true }), (angle) => {
          expect(transformAngle(angle)).toBeCloseTo(angle);
        })
      );
    });

    it("should preserve angle modulo 360", () => {
        fc.assert(
            fc.property(saneDouble, (angle) => {
                const transformed = transformAngle(angle);
                // The difference should be a multiple of 360
                const diff = Math.abs(angle - transformed);
                const remainder = diff % 360;
                // Allow for small floating point errors
                return remainder < 1e-4 || Math.abs(remainder - 360) < 1e-4;
            })
        )
    });
  });

  describe("getAngularDifference", () => {
    it("should always return a difference in [-180, 180]", () => {
      fc.assert(
        fc.property(saneDouble, saneDouble, (a, b) => {
          const diff = getAngularDifference(a, b);
          return diff >= -180 && diff <= 180;
        })
      );
    });

    it("should return 0 when angles are equal", () => {
      fc.assert(
        fc.property(saneDouble, (a) => {
          expect(getAngularDifference(a, a)).toBe(0);
        })
      );
    });

    it("adding difference to start should yield equivalent to end angle", () => {
        fc.assert(
            fc.property(saneDouble, saneDouble, (start, end) => {
                const diff = getAngularDifference(start, end);
                const result = start + diff;

                const a1 = transformAngle(result);
                const a2 = transformAngle(end);

                if (Math.abs(Math.abs(a1) - 180) < 1e-4 && Math.abs(Math.abs(a2) - 180) < 1e-4) return true;

                return Math.abs(a1 - a2) < 1e-4;
            })
        )
    });
  });

  describe("lerp", () => {
      it("should return start when t=0", () => {
          // Relax equality for signed zero
          fc.assert(
              fc.property(saneDouble, saneDouble, (start, end) => {
                  const res = lerp(0, start, end);
                  expect(Object.is(res, -0) ? 0 : res).toBe(Object.is(start, -0) ? 0 : start);
              })
          )
      });

      it("should return end when t=1", () => {
          // Relax equality for signed zero and precision
          fc.assert(
              fc.property(saneDouble, saneDouble, (start, end) => {
                  const res = lerp(1, start, end);
                  // Allow slightly more error for floating point lerp operations at extremes
                  expect(Math.abs(res - end)).toBeLessThan(1e-9);
              })
          )
      });

      it("should return midpoint when t=0.5", () => {
          fc.assert(
              fc.property(saneDouble, saneDouble, (start, end) => {
                  expect(lerp(0.5, start, end)).toBeCloseTo((start + end) / 2);
              })
          )
      });
  });

  describe("radiansToDegrees", () => {
      it("should scale linearly", () => {
          fc.assert(
              fc.property(saneDouble, (rad) => {
                  const deg = radiansToDegrees(rad);
                  const expected = rad * 180 / Math.PI;
                  return Math.abs(deg - expected) < 1e-6 * Math.abs(expected) + 1e-9;
              })
          )
      });
  });

  describe("getCurvePoint", () => {
      it("should return start point at t=0", () => {
          // Array of 2 to 5 points
          fc.assert(
              fc.property(fc.array(saneDoubleRecord, { minLength: 2, maxLength: 5 }), (points) => {
                  const result = getCurvePoint(0, points);
                  expect(result.x).toBeCloseTo(points[0].x);
                  expect(result.y).toBeCloseTo(points[0].y);
              })
          )
      });

      it("should return end point at t=1", () => {
        fc.assert(
            fc.property(fc.array(saneDoubleRecord, { minLength: 2, maxLength: 5 }), (points) => {
                const result = getCurvePoint(1, points);
                const last = points[points.length - 1];
                expect(result.x).toBeCloseTo(last.x);
                expect(result.y).toBeCloseTo(last.y);
            })
        )
    });
  });
});

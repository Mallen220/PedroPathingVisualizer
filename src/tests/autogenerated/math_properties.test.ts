// Copyright 2026 Matthew Allen. Licensed under the Apache License, Version 2.0.
import { describe, it, expect } from "vitest";
import * as fc from "fast-check";
import {
  transformAngle,
  getAngularDifference,
  lerp,
  radiansToDegrees,
  getCurvePoint,
  shortestRotation,
  lerp2d,
  quadraticToCubic,
  easeInOutQuad,
} from "../../utils/math";

// Helper to avoid Infinity/NaN in tests and excessively large numbers
// that cause floating point issues
const saneDouble = fc.double({ min: -1e6, max: 1e6, noNaN: true });
const saneDoubleRecord = fc.record({
  x: saneDouble,
  y: saneDouble,
});

// Helper for lerp-safe doubles (avoiding denormals near zero if needed, though mostly handled by range)
const lerpSafeDouble = saneDouble.filter((n) => Math.abs(n) > 1e-6 || n === 0);
const lerpSafeRecord = fc.record({
  x: lerpSafeDouble,
  y: lerpSafeDouble,
});

describe("Math Properties (Autogenerated)", () => {
  describe("transformAngle", () => {
    it("should always return an angle in [-180, 180)", () => {
      fc.assert(
        fc.property(saneDouble, (angle) => {
          const transformed = transformAngle(angle);
          return transformed >= -180 && transformed < 180;
        }),
      );
    });

    it("should be idempotent for angles already in range", () => {
      fc.assert(
        fc.property(
          fc.double({ min: -180, max: 179.999, noNaN: true }),
          (angle) => {
            expect(transformAngle(angle)).toBeCloseTo(angle);
          },
        ),
      );
    });

    it("should preserve angle modulo 360", () => {
      fc.assert(
        fc.property(saneDouble, (angle) => {
          const transformed = transformAngle(angle);
          // The difference should be a multiple of 360
          const diff = Math.abs(angle - transformed);
          const remainder = diff % 360;
          // Allow for small floating point errors
          return remainder < 1e-4 || Math.abs(remainder - 360) < 1e-4;
        }),
      );
    });
  });

  describe("getAngularDifference", () => {
    it("should always return a difference in [-180, 180]", () => {
      fc.assert(
        fc.property(saneDouble, saneDouble, (a, b) => {
          const diff = getAngularDifference(a, b);
          return diff >= -180 && diff <= 180;
        }),
      );
    });

    it("should return 0 when angles are equal", () => {
      fc.assert(
        fc.property(saneDouble, (a) => {
          expect(getAngularDifference(a, a)).toBe(0);
        }),
      );
    });

    it("adding difference to start should yield equivalent to end angle", () => {
      fc.assert(
        fc.property(saneDouble, saneDouble, (start, end) => {
          const diff = getAngularDifference(start, end);
          const result = start + diff;

          const a1 = transformAngle(result);
          const a2 = transformAngle(end);

          if (
            Math.abs(Math.abs(a1) - 180) < 1e-4 &&
            Math.abs(Math.abs(a2) - 180) < 1e-4
          )
            return true;

          return Math.abs(a1 - a2) < 1e-4;
        }),
      );
    });
  });

  describe("lerp", () => {
    it("should return start when t=0", () => {
      // Relax equality for signed zero
      fc.assert(
        fc.property(lerpSafeDouble, lerpSafeDouble, (start, end) => {
          const res = lerp(0, start, end);
          expect(Math.abs(res - start)).toBeLessThan(1e-9);
        }),
      );
    });

    it("should return end when t=1", () => {
      // Relax equality for signed zero and precision
      fc.assert(
        fc.property(lerpSafeDouble, lerpSafeDouble, (start, end) => {
          const res = lerp(1, start, end);
          // Allow slightly more error for floating point lerp operations at extremes
          expect(Math.abs(res - end)).toBeLessThan(1e-9);
        }),
      );
    });

    it("should return midpoint when t=0.5", () => {
      fc.assert(
        fc.property(saneDouble, saneDouble, (start, end) => {
          expect(lerp(0.5, start, end)).toBeCloseTo((start + end) / 2);
        }),
      );
    });
  });

  describe("lerp2d", () => {
    it("should return start point at ratio 0 and end point at ratio 1", () => {
      fc.assert(
        fc.property(lerpSafeRecord, lerpSafeRecord, (start, end) => {
          const resStart = lerp2d(0, start, end);
          const resEnd = lerp2d(1, start, end);

          expect(Math.abs(resStart.x - start.x)).toBeLessThan(1e-9);
          expect(Math.abs(resStart.y - start.y)).toBeLessThan(1e-9);
          expect(Math.abs(resEnd.x - end.x)).toBeLessThan(1e-9);
          expect(Math.abs(resEnd.y - end.y)).toBeLessThan(1e-9);
        }),
      );
    });
  });

  describe("shortestRotation", () => {
    it("should interpolate correctly at t=0 and t=1", () => {
      fc.assert(
        fc.property(
          fc.double({ min: -360, max: 360, noNaN: true }),
          fc.double({ min: -360, max: 360, noNaN: true }),
          (start, end) => {
            const rot0 = shortestRotation(start, end, 0);
            const rot1 = shortestRotation(start, end, 1);

            expect(rot0).toBeCloseTo(start, 5);

            // rot1 should be equivalent to end
            const diff = getAngularDifference(rot1, end);
            expect(Math.abs(diff)).toBeLessThan(1e-5);
          },
        ),
      );
    });
  });

  describe("quadraticToCubic", () => {
    it("should generate control points that define the same curve", () => {
      // It's hard to verify "same curve" without evaluating points,
      // but we can verify the formula consistency
      fc.assert(
        fc.property(
          saneDoubleRecord,
          saneDoubleRecord,
          saneDoubleRecord,
          (p0, p1, p2) => {
            const { Q1, Q2 } = quadraticToCubic(p0, p1, p2);

            // Q1 = P0 + (2/3)(P1 - P0)
            expect(Q1.x).toBeCloseTo(p0.x + (2 / 3) * (p1.x - p0.x));
            expect(Q1.y).toBeCloseTo(p0.y + (2 / 3) * (p1.y - p0.y));

            // Q2 = P2 + (2/3)(P1 - P2)
            expect(Q2.x).toBeCloseTo(p2.x + (2 / 3) * (p1.x - p2.x));
            expect(Q2.y).toBeCloseTo(p2.y + (2 / 3) * (p1.y - p2.y));
          },
        ),
      );
    });
  });

  describe("easeInOutQuad", () => {
    it("should be within [0, 1] for input in [0, 1]", () => {
      fc.assert(
        fc.property(fc.double({ min: 0, max: 1, noNaN: true }), (t) => {
          const eased = easeInOutQuad(t);
          return eased >= 0 && eased <= 1;
        }),
      );
    });

    it("should be monotonically increasing for input in [0, 1]", () => {
      fc.assert(
        fc.property(
          fc.double({ min: 0, max: 1, noNaN: true }),
          fc.double({ min: 0, max: 1, noNaN: true }),
          (a, b) => {
            const min = Math.min(a, b);
            const max = Math.max(a, b);
            return easeInOutQuad(min) <= easeInOutQuad(max);
          },
        ),
      );
    });
  });

  describe("radiansToDegrees", () => {
    it("should scale linearly", () => {
      fc.assert(
        fc.property(saneDouble, (rad) => {
          const deg = radiansToDegrees(rad);
          const expected = (rad * 180) / Math.PI;
          return Math.abs(deg - expected) < 1e-6 * Math.abs(expected) + 1e-9;
        }),
      );
    });
  });

  describe("getCurvePoint", () => {
    it("should return start point at t=0", () => {
      // Array of 2 to 5 points
      fc.assert(
        fc.property(
          fc.array(saneDoubleRecord, { minLength: 2, maxLength: 5 }),
          (points) => {
            const result = getCurvePoint(0, points);
            expect(result.x).toBeCloseTo(points[0].x);
            expect(result.y).toBeCloseTo(points[0].y);
          },
        ),
      );
    });

    it("should return end point at t=1", () => {
      fc.assert(
        fc.property(
          fc.array(saneDoubleRecord, { minLength: 2, maxLength: 5 }),
          (points) => {
            const result = getCurvePoint(1, points);
            const last = points[points.length - 1];
            expect(result.x).toBeCloseTo(last.x);
            expect(result.y).toBeCloseTo(last.y);
          },
        ),
      );
    });
  });
});

// Copyright 2026 Matthew Allen. Licensed under the Apache License, Version 2.0.
import { describe, it, expect } from "vitest";
import * as fc from "fast-check";
import {
  transformAngle,
  getAngularDifference,
  lerp,
  radiansToDegrees,
  getCurvePoint,
  shortestRotation,
} from "../../utils/math";

// Helper to avoid Infinity/NaN in tests and excessively large numbers
// that cause floating point issues
const saneDouble = fc.double({ min: -1e6, max: 1e6, noNaN: true });
const saneDoubleRecord = fc.record({
  x: saneDouble,
  y: saneDouble,
});

describe("Math Properties (Autogenerated)", () => {
  describe("transformAngle", () => {
    it("should always return an angle in [-180, 180)", () => {
      fc.assert(
        fc.property(saneDouble, (angle) => {
          const transformed = transformAngle(angle);
          return transformed >= -180 && transformed < 180;
        }),
      );
    });

    it("should be idempotent for angles already in range", () => {
      fc.assert(
        fc.property(
          fc.double({ min: -180, max: 179.999, noNaN: true }),
          (angle) => {
            expect(transformAngle(angle)).toBeCloseTo(angle);
          },
        ),
      );
    });

    it("should preserve angle modulo 360", () => {
      fc.assert(
        fc.property(saneDouble, (angle) => {
          const transformed = transformAngle(angle);
          // The difference should be a multiple of 360
          const diff = Math.abs(angle - transformed);
          const remainder = diff % 360;
          // Allow for small floating point errors
          return remainder < 1e-4 || Math.abs(remainder - 360) < 1e-4;
        }),
      );
    });
  });

  describe("getAngularDifference", () => {
    it("should always return a difference in [-180, 180]", () => {
      fc.assert(
        fc.property(saneDouble, saneDouble, (a, b) => {
          const diff = getAngularDifference(a, b);
          return diff >= -180 && diff <= 180;
        }),
      );
    });

    it("should return 0 when angles are equal", () => {
      fc.assert(
        fc.property(saneDouble, (a) => {
          expect(getAngularDifference(a, a)).toBe(0);
        }),
      );
    });

    it("adding difference to start should yield equivalent to end angle", () => {
      fc.assert(
        fc.property(saneDouble, saneDouble, (start, end) => {
          const diff = getAngularDifference(start, end);
          const result = start + diff;

          const a1 = transformAngle(result);
          const a2 = transformAngle(end);

          if (
            Math.abs(Math.abs(a1) - 180) < 1e-4 &&
            Math.abs(Math.abs(a2) - 180) < 1e-4
          )
            return true;

          return Math.abs(a1 - a2) < 1e-4;
        }),
      );
    });
  });

  describe("shortestRotation", () => {
    it("should interpolate correctly between angles", () => {
      fc.assert(
        fc.property(saneDouble, saneDouble, fc.double({min: 0, max: 1, noNaN: true}), (start, end, t) => {
          const result = shortestRotation(start, end, t);
          const diff = getAngularDifference(start, end);

          // result should be start + diff * t
          const expected = start + diff * t;
          expect(result).toBeCloseTo(expected);
        })
      );
    });

    it("should be consistent with getAngularDifference", () => {
      fc.assert(
        fc.property(saneDouble, saneDouble, (start, end) => {
           // at t=1, we should be at 'end' (modulo 360)
           const result = shortestRotation(start, end, 1);
           const diff = getAngularDifference(start, end);

           const endReconstructed = start + diff;
           expect(result).toBeCloseTo(endReconstructed);

           // Verify it matches end modulo 360
           const angle1 = transformAngle(result);
           const angle2 = transformAngle(end);

           // Handle singularity at 180/-180
           if (Math.abs(Math.abs(angle1) - 180) < 1e-4 && Math.abs(Math.abs(angle2) - 180) < 1e-4) return;

           expect(angle1).toBeCloseTo(angle2);
        })
      );
    });
  });

  describe("lerp", () => {
    it("should return start when t=0", () => {
      // Relax equality for signed zero
      fc.assert(
        fc.property(saneDouble, saneDouble, (start, end) => {
          const res = lerp(0, start, end);
          expect(Object.is(res, -0) ? 0 : res).toBe(
            Object.is(start, -0) ? 0 : start,
          );
        }),
      );
    });

    it("should return end when t=1", () => {
      // Relax equality for signed zero and precision
      fc.assert(
        fc.property(saneDouble, saneDouble, (start, end) => {
          const res = lerp(1, start, end);
          // Allow slightly more error for floating point lerp operations at extremes
          expect(Math.abs(res - end)).toBeLessThan(1e-9);
        }),
      );
    });

    it("should return midpoint when t=0.5", () => {
      fc.assert(
        fc.property(saneDouble, saneDouble, (start, end) => {
          expect(lerp(0.5, start, end)).toBeCloseTo((start + end) / 2);
        }),
      );
    });
  });

  describe("radiansToDegrees", () => {
    it("should scale linearly", () => {
      fc.assert(
        fc.property(saneDouble, (rad) => {
          const deg = radiansToDegrees(rad);
          const expected = (rad * 180) / Math.PI;
          return Math.abs(deg - expected) < 1e-6 * Math.abs(expected) + 1e-9;
        }),
      );
    });
  });

  describe("getCurvePoint", () => {
    it("should return start point at t=0", () => {
      // Array of 2 to 5 points
      fc.assert(
        fc.property(
          fc.array(saneDoubleRecord, { minLength: 2, maxLength: 5 }),
          (points) => {
            const result = getCurvePoint(0, points);
            expect(result.x).toBeCloseTo(points[0].x);
            expect(result.y).toBeCloseTo(points[0].y);
          },
        ),
      );
    });

    it("should return end point at t=1", () => {
      fc.assert(
        fc.property(
          fc.array(saneDoubleRecord, { minLength: 2, maxLength: 5 }),
          (points) => {
            const result = getCurvePoint(1, points);
            const last = points[points.length - 1];
            expect(result.x).toBeCloseTo(last.x);
            expect(result.y).toBeCloseTo(last.y);
          },
        ),
      );
    });

    it("should lie within the convex hull (bounding box) of control points", () => {
       fc.assert(
         fc.property(
           fc.array(saneDoubleRecord, { minLength: 2, maxLength: 5 }),
           fc.double({ min: 0, max: 1, noNaN: true }),
           (points, t) => {
             const result = getCurvePoint(t, points);

             // A point on a Bezier curve must lie within the convex hull of its control points.
             // Checking full convex hull is complex here without importing geometry utils.
             // But we can check the bounding box, which is a necessary condition.
             const xs = points.map(p => p.x);
             const ys = points.map(p => p.y);

             const minX = Math.min(...xs);
             const maxX = Math.max(...xs);
             const minY = Math.min(...ys);
             const maxY = Math.max(...ys);

             // Allow for floating point error
             expect(result.x).toBeGreaterThanOrEqual(minX - 1e-6);
             expect(result.x).toBeLessThanOrEqual(maxX + 1e-6);
             expect(result.y).toBeGreaterThanOrEqual(minY - 1e-6);
             expect(result.y).toBeLessThanOrEqual(maxY + 1e-6);
           }
         )
       );
    });
  });
});

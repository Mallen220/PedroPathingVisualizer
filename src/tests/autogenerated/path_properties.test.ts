// Copyright 2026 Matthew Allen. Licensed under the Apache License, Version 2.0.
import { describe, it, expect } from "vitest";
import * as fc from "fast-check";
import { analyzePathSegment } from "../../utils/timeCalculator";
import { Point, BasePoint } from "../../types";

// Generators for types
const pointArb = fc.record({
  x: fc.double({ min: -1000, max: 1000, noNaN: true }),
  y: fc.double({ min: -1000, max: 1000, noNaN: true }),
});

const basePointArb = pointArb.map((p) => ({ ...p }));

describe("Path Properties (Autogenerated)", () => {
  describe("analyzePathSegment", () => {
    it("should always return non-negative length", () => {
      fc.assert(
        fc.property(
          basePointArb,
          fc.array(basePointArb, { maxLength: 3 }), // Control points
          basePointArb,
          fc.double({ min: -360, max: 360, noNaN: true }), // Initial heading
          (start, cps, end, initialHeading) => {
            const analysis = analyzePathSegment(
              start,
              cps,
              end,
              10,
              initialHeading,
            );

            expect(analysis.length).toBeGreaterThanOrEqual(0);
            expect(Number.isFinite(analysis.length)).toBe(true);
          },
        ),
      );
    });

    it("should generate steps matching samples count", () => {
      fc.assert(
        fc.property(
          basePointArb,
          fc.array(basePointArb, { maxLength: 3 }), // Control points
          basePointArb,
          (start, cps, end) => {
            const samples = 10;
            const analysis = analyzePathSegment(start, cps, end, samples, 0);

            // Steps are pushed for i > 0, so samples steps.
            expect(analysis.steps.length).toBe(samples);
          },
        ),
      );
    });

    it("total length should be approximately sum of step deltaLengths", () => {
      fc.assert(
        fc.property(
          basePointArb,
          fc.array(basePointArb, { maxLength: 3 }), // Control points
          basePointArb,
          (start, cps, end) => {
            const analysis = analyzePathSegment(start, cps, end, 10, 0);

            const sum = analysis.steps.reduce(
              (acc, step) => acc + step.deltaLength,
              0,
            );
            // The current implementation calculates length by summing the steps.
            // If implementation changes to arc length integration, this might need a looser epsilon.
            expect(sum).toBeCloseTo(analysis.length);
          },
        ),
      );
    });

    it("linear segment length should be euclidean distance", () => {
      fc.assert(
        fc.property(basePointArb, basePointArb, (start, end) => {
          const analysis = analyzePathSegment(start, [], end, 10, 0);
          const expected = Math.hypot(end.x - start.x, end.y - start.y);
          expect(analysis.length).toBeCloseTo(expected);
        }),
      );
    });
  });
});
